/* autogenerated by Processing revision 1283 on 2022-05-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class PROJEKAT extends PApplet {

//Marko Martinovic RT-72/20

Raketa Raketa;
Populacija Populacija;
PVector target;
float maxsila = 0.2f;

int age;//vreme trajanja raketa
float stat;//neka statistika uspesnosti

int generation = 0;//pocetna generacija je 0

//pozicije prepreke po x i y osi, njena duzina i sirina
float barrierx;
float barriery;
float barrierw;
float barrierh;

 public void setup() {
  /* size commented out by preprocessor */;//"rezolucija prozora"
  Populacija = new Populacija();
  Raketa = new Raketa();
  target = new PVector(width / 2, 120);//pozicija meseca
  age = 0;

  stat = 0;

//pravljenje prepreke(sirina, duzina,pozicija po x i y osi)
  barrierw = width / 8;
  barrierh = 10;
  barrierx = (width - barrierw) / 2;
  barriery = (height - barrierh) / 2;
}

//funkcija za pozadinu(svemir) 
 public void draw() {
  background(0);

//crtanje mete(meseca)
  stroke(255);
  fill(128);
  ellipse(target.x, target.y, 200, 200);
  fill(100);
  noStroke();
  strokeWeight(2);
  ellipse(target.x+2, target.y-2, 10, 10);

  //crtanje prepreke
  fill(0, 255, 0);
  stroke(128);
  rectMode(CORNER);
  rect(barrierx, barriery, barrierw, barrierh);
  strokeWeight(1);
  stroke(55, 0, 0);
  fill(255);

//crtanje ostalih svemirskih tela(simuliranje zvezdi)
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
ellipse(random(1400),random(1400),random(10),random(10));
  
  Populacija.pokreni();

  age++;
  if (age >= zivotniVek) {
    stat = Populacija.evaluacija();
    Populacija.selekcija();
    age = 0;
    generation++;
  }

  textSize(18);
  noStroke();
  fill(0, 250, 250);
  text("Generacija: " + generation, 20, 20);
  text("Zivotni vek: " + age, 20, 40);
  if (stat != 0) {
    text("Statistika uspesnosti: " + stat, 20, 60);
  }
}

//DNA fajl omogucava raketama nacin kretanja.
//Svaka raketa u sebi sadrzi neprebrojivo mnogo "receptora" i svaki taj receptor sadrzi neprebrojivi niz vektora pomocu kojih se raketa krece u prostoru. 

//ukljucivanje biblioteke java.util koja sadrzi modele dogadjaja, objekte za datum i vreme, klase prikupljanja...


int zivotniVek = 500; //duzina trajanja samog zivotnog veka raketa


//pravljenje klase DNA koja sadrzi sve te "receptore" od nebrojano mnogo nizova vektora koji omogucavaju nasumicno kretanje raketa u prostoru.
class DNA {
  PVector[] genes;


//svaki "receptor" je u stvari neki gen koji sadrzi nebrojano mnogo vektora, svaki taj vektor je niz brojeva odnosno razlicitih putanja kojima ce se raketa kretati.
//u ovom delu koda svakom tom genu dodeljujemo novi niz vektora gde ce ti geni postojati sve dokle traje zivotni vek rakete.
  DNA() {
    genes = new PVector[zivotniVek];

    for (int i = 0; i < zivotniVek; i++) {
      PVector gene = PVector.random2D();
      gene.setMag(maxsila);        
      genes[i] = gene;
    }
  }

  DNA(PVector[] genes_) {
    genes = Arrays.copyOf(genes_, genes_.length);
  }

//ukrstanje dve jedinke i formiranje nove jedinke
//da bismo dobili novu jedinku moramo uzeti neke nasumicne gene iz prethodne generacije, u ovom slucaju duzina gena nam je ustvari neki vektor(koji je niz nasumicnih brojeva koji odredjuju kretanje rakete) i kroz petlju mi prolazimo kroz te duzine, uzimajuci nove vrednosti za forimiranje gena za novu jedinku.
   public DNA crossover(DNA partner) {
    PVector[] newgenes = new PVector[genes.length];
    int mid = (int) random(genes.length);
    for (int i = 0; i < genes.length; i++) {
      if (i > mid) {
        newgenes[i] = genes[i];
      } else {
        newgenes[i] = partner.genes[i];
      }
    }
    return new DNA(newgenes);
  }
//ovde imamo funkciju mutacije koja radi tako sto se jedan postojeci get promeni u maloj meri.
//isto nam je potrebna petlja da bismo prosli kroz duzinu gena i na kraju nasumicnom genu dodeljujemo neku novu vrednost
   public void mutacija() {
    for (int i = 0; i < genes.length; i++) {
      if (random(i) < 0.01f) {
        PVector gene = PVector.random2D();
        gene.setMag(maxsila);        
        genes[i] = gene;
      }
    }
  }
}
//kreiramo klasu populacija koja sadrzi ukupan broj jedinki, njihovu evaluaciju, ukrstanje

class Populacija {
  Raketa[] Rakete;
  int velicinaPopulacije;
  List<Raketa> umnozavanje;

//metoda populacija sadrzi velicinu populacije koji je ustvari dinamicki niz
  Populacija() {
    velicinaPopulacije = 50;
    Rakete = new Raketa[velicinaPopulacije];
    umnozavanje = new ArrayList<Raketa>();

    for (int i = 0; i < velicinaPopulacije; i++) {
      Rakete[i]  = new Raketa();//dodavanje novih raketa u niz
    }
  }

//ova funkcija za evaluaciju koristi fitnes da bi se utvrdilo koliko su dobre jedinke
   public float evaluacija() {
    float avgfit = 0;//postavljanje prosecnog fitnesa na 0
    float maxfit = 0;//postavljanje maksimalnog fitnesa na 0
    for (Raketa Raketa : Rakete) {
      Raketa.racunajFitness();
      if (Raketa.fitness > maxfit) {
        maxfit = Raketa.fitness;
      }
      avgfit += Raketa.fitness;
    }
    avgfit /= Rakete.length;

    for (Raketa Raketa : Rakete) {
      Raketa.fitness /= maxfit;
    }

    umnozavanje = new ArrayList<Raketa>();

    for (Raketa Raketa : Rakete) {
      float n = Raketa.fitness * 100;
      for (int j = 0; j < n; j++) {
        umnozavanje.add(Raketa);
      }
    }

    return avgfit;
  }

   public Raketa random(List<Raketa> list) {
    int r = (int)(Math.random() * (list.size()));
    return list.get(r);
  }

//ovom funkcijom vrsi se selekcija "roditelja", biraju se dva roditelja i od njih nastaje potomak
   public void selekcija() {
    Raketa[] newRakete = new Raketa[velicinaPopulacije];
    for (int i = 0; i < Rakete.length; i++) {
      DNA parentA = random(umnozavanje).dna;
      DNA parentB = random(umnozavanje).dna;
      DNA child = parentA.crossover(parentB);
      child.mutacija();
      newRakete[i] = new Raketa(child);
    }

    Rakete = newRakete;
  }

   public void pokreni() {
    for (Raketa Raketa : Rakete) {
      Raketa.update();
      Raketa.show();
    }
  }
}

//fajl u kome struktuiramo raketu

final float maxBrzina = 4;

//pravimo klasu Raketa koja sadrzi svoju poziciju(koja je odredjena u koordinatnom prostoru), brzinu, ubrzanje, sadrzi klasu DNA jer se u njoj nalaze geni rakete, imamo fitnes funkciju odnosno funkciju dobrote koja na osnovu ulaza(jedinke) govori koliko je evaluirala.
class Raketa {
  PVector poz;
  PVector brz;
  PVector ubrz;
  DNA dna;
  float fitness = 0;
  
//boolean vrednosti koje nam sluze u slucaju da se rakete sudare sa zamisljenim zidom ili u slucaju ako dospeju do krajnjeg cilja.
  boolean hitTarget = false;
  boolean crashed = false;

//metoda Raketa koja ce sadrzati pokazivac na niz na metodu DNA koja sadrzi sve najbitnije informacije o kretanju rakete
  Raketa() {
    this(new DNA());
  }

//postavljamo pocetnu poziciju vektora po x i y osi, brzinu i ubrzanje, u slucaju udara u "zamisljeni zid" ili "sletanje" na mesec, rakete se zaustavljaju
  Raketa(DNA dna_) {
    poz = new PVector(width / 2, height - 20);
    brz = new PVector();
    ubrz = new PVector(0, -0.01f);
    dna = dna_;
    fitness = 0;
    hitTarget = false;
    crashed = false;
  }

//funkcija koja prihvata silu, tacnije funkcija koja definise koliko brzo ce se kretati rakete
   public void prihvatiSilu(PVector sila) {
    ubrz.add(sila);
  }

//funkcija koja racuna fitness(uspesnost raketa)
   public void racunajFitness() {
    float d = distanceToTarget();
    fitness = map(d, 0, width, width, 0);
    if (hitTarget) {
      fitness *= 10;
    } else if (crashed) {
      fitness /= 10;
    }
  }

//udaljenost od cilja
   public float distanceToTarget() {
    return dist(poz.x, poz.y, target.x, target.y);
  }

//ovde upotrebljavamo funkciju udaljenosti od cilja i proveravamo da li je raketa udarila u zid ili u metu(mesec)
   public void update() {
    float d = distanceToTarget();
    if (d < 100) {
      hitTarget = true;
      
    }

    if (poz.x > barrierx && poz.x < (barrierx + barrierw) && poz.y > barriery && poz.y < (barriery + barrierh)) {
      crashed = true;
    }
    if (poz.x > width || poz.x < 0 || poz.y > height || poz.y < 0) {
      crashed = true;
    }

    prihvatiSilu(dna.genes[age]);

    if (!hitTarget && !crashed) {
      brz.add(ubrz);
      poz.add(brz);
      ubrz.mult(0);
      brz.limit(maxBrzina);
    }
  }
  
//prikazivanje raketa, u slucaju da pogode metu(mesec) rakete ce pozeleneti, u slucaju sudara u "zamisljeni zid" raketa ce pocrveneti
   public void show() {
    pushMatrix();
    noStroke();
    if (hitTarget) {
      fill(50, 205, 50);
    } else if (this.crashed) {
      fill(250, 0, 0);
    } else {
      fill(255, 150);
    }
    
//translacija i rotacija raketa u prostoru
    translate(poz.x, poz.y);
    rotate(brz.heading());

//pravljenje "tela" rakete
    rectMode(CENTER);
    rect(0, 0, 25, 5);

//crtanje "nosa" rakete
    fill(165, 42, 42);
    ellipse(12, 0, 50, 5);

    if (!hitTarget && !crashed) {
//crtanje plamena koji izlazi iz rakete
      fill(255, 140 + random(0, 115), random(0, 128));
      beginShape();
      vertex(-14, -3);
      vertex(-55, 0);
      vertex(-14, 3);
      endShape();
    }

    popMatrix();
  }
}


  public void settings() { size(1024, 768); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "PROJEKAT" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
